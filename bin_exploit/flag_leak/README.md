### Current progress: Done

A `vuln` binary and its source file `vuln.c` is given.
The `vuln` is a i386-32bit little-endian binary.

Looking at the source file, we found this:

```c
void vuln(){
   char flag[BUFSIZE];
   char story[128];

   readflag(flag, FLAGSIZE);

   printf("Tell me a story and then I'll tell you one >> ");
   scanf("%127s", story);
   printf("Here's a story - \n");
   printf(story);
   printf("\n");
}
```

The thing that caught our attention is `printf(story)`.
Usually, when you pass in a variable to `printf` in c,
you do it somewhere along the lines of the following:

```c
char str[5] = "test";
printf(%s\n, str);
```

After some research, we found out the reason 
why the variable shouldn't be passed in directly to `printf`.

It is because of `format string vulnerability`.
We found two articles that is helpful to us: [ctf101's](https://ctf101.org/binary-exploitation/what-is-a-format-string-vulnerability/) and [OWASP's](https://owasp.org/www-community/attacks/Format_string_attack). Ironically, we also found a solution to picoCTF2018's version of this challenge from [John Hammond's video'](https://youtu.be/EmLfoR-k_l0)

From these sources, it seems like we can use `%n$s` to print out 
the string (`$s`) from the `n` position relative to the current buffer. So, we made [find_fmtstr_offset.py](find_fmtstr_offset.py) to repeatedly run the binary and prints out the offset of the flag.
The script gives us the offset `24`.

From the offset above, we input `%24$s` on the server binary (on netcat) and got `CTF{L34k1ng_Fl4g_0ff_St4ck_eb9b46a2}`. It seems like it cuts of the first 4 characters of the flag. This isn't a problem, however, since we know it is just `pico`.

So the flag is: `picoCTF{L34k1ng_Fl4g_0ff_St4ck_eb9b46a2}`