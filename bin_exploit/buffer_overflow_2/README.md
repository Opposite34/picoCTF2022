### Current progress: Done

Similar to other buffer overflow challenges. We are given the `vuln` executable and the `vuln.c` source code.

`file` and `checksec` command show this executable to be:
- little endian, 32bit, and i386
- NX enabled

Since this is NX enabled (marking some addresses as no-execute), a traditional buffer overflow attack *may* not be possible.

From researching, we found that a [return to libc attack](https://0x10f8.wordpress.com/2019/05/21/subverting-nx-bit-with-return-to-libc/) is used to bypass this security protection. 

Another (similar) way to bypass this protection is through Return-oriented programming (ROP) as demonstrated here on [John Hammond's video](https://youtu.be/i5-cWI_HV8o).

First, let's look at the c source code. There are two things that seemed to be of note:

First, the `vuln` function:
```
void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}
```
As you can see, this function uses `gets` function. 
This has similar effect to using `strcpy` previously mentioned, 
i.e. it is not safe and is the attack vector in these kinds of buffer overflow exploit.


Next is this part from the `win` function (only shown here are the interested lines).
```
void win(unsigned int arg1, unsigned int arg2) {
    char buf[FLAGSIZE];
    FILE *f = fopen("flag.txt","r");
    ...

    char buf[FLAGSIZE];
    fgets(buf,FLAGSIZE,f);
    if (arg1 != 0xCAFEF00D)
        return;
    if (arg2 != 0xF00DF00D)
        return;
    printf(buf);
}
```
As shown above, it needs two specific arguments to be able to print the `buf` where our flag is stored in the end.
This means we either have to bypass these arguments or run the function using them somehow.


Then, we looked into running cyclic on the offset by using `dmesg | tail` as shown below (this is on WSL2, so some stuffs are different from a normal linux distro):
![cyclic_offset](cyclic_offset.jpg)

We then made our [exploit.py](exploit.py). 
At first, we used `rop.call(elf.symbols['win'], [int(CAFEF00D, 16), int(F00DF00D, 16)])`

However, after looking at the ROP chain. We realized that we can learn much more from doing it somewhat 'manually'.

Instead of running the ROP, we added a 4 bytes padding between the function call and the arguments.
This seems to work perfectly fine, and give us the follow flag:
`picoCTF{argum3nt5_4_d4yZ_2a8ec317}`

Seems like the `ret2libc` and `ROP` are not necessary here because `win` is not the function that `NX` touched.
We probably need them later on in the future for gaining access to the shell in some other challenges.