### Current progress: not done

A `vuln` and `vuln.c` file and source code file is given

`vuln` is a i386, 32bit little endian executable (checked via `checksec` command).
It also has NX enabled.

Looking into the code, we found something interesting with it:
```c
#define CANARY_SIZE 4

...

if (memcmp(canary,global_canary,CANARY_SIZE)) {
    printf("***** Stack Smashing Detected ***** : Canary Value Corrupt!\n"); // crash immediately
    exit(-1);
}
```
Seems like the file has its own stack canary check!
The canary seems to be 4 bytes in size.

Let's set the `canary.txt` file for testing locally to `test` for now and deal with the canary later.

After this, we found from the source code that we have to specify the write size - the file will only read as much as we said:

```c
#define BUFSIZE 64

...

void vuln(){
   ...

   printf("How Many Bytes will You Write Into the Buffer?\n> ");

   while (x<BUFSIZE) {
      read(0,length+x,1);
      if (length[x]=='\n') break;
      x++;
   }
   sscanf(length,"%d",&count);

   printf("Input> ");
   read(0,buf,count);

   ...
}
```

However, it seems like the code stills rely on `BUFSIZE` which is set to 64.
This means that we can still allow overflowing by giving the write input a large number, and it would all be okay for us to do the exploit.

With our knowledge above, we: 
- Used `pwndbg`
- Set the breakpoint at the end of main
- Did some fuzzing with the offset
- Checked the `RIP` address if it is overwritten correct

In which we found out how our payload would look like:
```
64-byte offset + canary + 16-byte offset + address to execute (win func)
```

Using above payload design with the local canary value of `test`, we successfully executed the exploit and got our test flag.

### TODO: 
Find a way to leak / bypass the stack canary on the server