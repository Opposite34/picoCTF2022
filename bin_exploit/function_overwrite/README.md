### Current progress: Done

A `vuln` binary and `vuln.c` source code is given.

The source code has accepts the following inputs:
- a string for checking it's value.
- two integer for setting value of an array at that index.

It seems like there is a function pointer `check` which is used to call `hard_checker`. This `hard_checker` for loops and sum through each character in the string, and then prints out the flag if its value matches `13371337`.

This however, is impossible because the string len is only set to 128 as shown in: `char story[128];`

But, there is another function `easy_checker`, which essentially does the same thing as `hard_checker` but comparing it to the value `1337` instead.

If we are able to run `easy_checker`, we can supply it ten `z` characters (`122*10 = 1220`) and one `u` (`117`) which totalled to exactly `1220+117=1337` 



Using the hints and the tags provided in the challenge. We found the vulnerability related to the following codes:

```c
void (*check)(char*, size_t) = hard_checker;

...

void vuln()
{
    ...

    scanf("%127s", story);
    scanf("%d %d", &num1, &num2);

    if (num1 < 10)
    {
        fun[num1] += num2;
    }

    check(story, strlen(story));
}
```

This codes suffer from an `Array Out-of-bounds` exploit. From [cwe.mitre.org](https://cwe.mitre.org/data/definitions/125.html), it stated that if the inputted index isn't checked for the minimum value - it can be provided a negative number.

We tinkered with the value in `ghidra` and `pwndbg` and found out that:
- `fun` array's address is `64` decimal difference from `check` function pointer.
- To manipulate the `check` function pointer, we have to provided the index to `fun` to be `-64/4-bytes-per-addr = -16`
- We then found out that the address of `hard_checker` is `314` decimal after `easy_checker`.
- This means we can give the binary `-314` for its second value, which will point to the address of `easy_checker`.

This means our input will be: 
```
zzzzzzzzzzu
-16 -314
```

After we checked that this exploit works locally, we ran it on picoCTF's network and acquired the following output:
```
Tell me a story and then I'll tell you if you're a 1337 >> zzzzzzzzzzu
On a totally unrelated note, give me two numbers. Keep the first one less than 10.
-16 -314
You're 1337. Here's the flag.
picoCTF{0v3rwrit1ng_P01nt3rs_f61460f0}
```

From the above, we find our flag to be: `picoCTF{0v3rwrit1ng_P01nt3rs_f61460f0}`