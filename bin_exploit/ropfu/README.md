### Current progress: not done

The `vuln` binary and `vuln.c` source file was given.

According to the `checksec` command, `vuln` is an i386, 32bit little-endian binary with stack canary.

From searching up stack canary, we found [this post on CTF101](https://ctf101.org/binary-exploitation/stack-canaries/) explaining
how stack canary detects buffer overflow attacks. 

However, `checksec` also shows us that there are `RWX segments` (read, write, execute), which could be handy for us (an attacker).

Running the `vuln` prompts `How strong is your ROP-fu? Snatch the shell from my hand, grasshopper!` and asks us for
an input.

From the challenge name and this prompt, it leads us to believe that we have to use Return-Oriented Programming (ROP) type
of buffer overflow attack on this binary.

We looked into [John Hammond's video](https://youtu.be/i5-cWI_HV8o) on ROP to see how we could craft our [exploit.py](exploit.py).

However, we are unable to find anything at all in the GOT (Global Offset Table) produced by `pwntools`...

---

After some time has passed... we came back to this challenge again.

It seems like this is a `statically linked` binary according to `file`. This means that we do not have to leak the libc from the server, since it will be the same one with ours.

What we tried:
- Searching for `exec` or `system` function family.
- Searching for `/bin/sh` in the binary.
- Finding `jmp esp` or some other ROP gadgets that sets the `EIP` to `ESP`

After some trial and error, we found an `jmp esp` instruction using the command: `ropper -f vuln --jmp esp` at `0x080b075a: push esp; ret;`

So we can write our buffer overflow payload to be the following:
- buffer overflow offset to the `EIP`
- the rop gadget to return `EIP` to the `ESP`
- the shellcode to gain shell access (inside of `ESP`)

Running this on the server gives us the shell, in which we can `ls` and `cat flag.txt`.
The flag we got is: `picoCTF{5n47ch_7h3_5h311_029ab653}`